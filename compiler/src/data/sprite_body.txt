r#"
#[derive(Default, Clone, Debug)]
pub struct {name} {{
{fields}}}
impl {name} {{
{procs}
}}
impl Sprite<Stage, Backend> for {name} {{
    fn receive(&mut self, ctx: &mut Ctx, msg: Trigger<Msg>) {{
        let this = self;
        // All the plumbing exists for the compiler to put things here but currently it doesn't.
        match msg {{
            {sync_handlers}
            _ => {{}}  // Ignored. Nothing sync cares about this event.
        }}
    }}

    fn receive_async(&self, msg: Trigger<Msg>) -> Box<FnFut<Stage, Backend>> {{
        Box::new(move |ctx, this| {{
            let this: &mut Self = ctx.trusted_cast(this);
            nosuspend!(this.receive(ctx, msg));  // TODO: does scratch define an ordering?
            match msg {{
                {async_handlers}
                _ => IoAction::None.done(),  // Ignored. Nothing async cares about this event
            }}
        }})
    }}

    // Grumble grumble object safety...
    fn clone_boxed(&self) -> Box<dyn Sprite<Stage, Backend>> {{ Box::new(self.clone()) }}

    #[cfg(feature = "inspect")]
    fn get_var_names(&self) -> &'static [&'static str] {{
        &[{var_names}]
    }}

    #[cfg(feature = "inspect")]
    fn var(&self, i: usize) -> runtime::ui::VarBorrow {{
        use runtime::ui::VarBorrow as V;
        match i {{
            {visit_vars}
            _ => V::Fail,
        }}
    }}

    #[cfg(feature = "inspect")]  // TODO: alas we're getting to the point of wanting a console scripting language.... if only someone had a nice ast
    fn var_mut(&mut self, i: usize) -> runtime::ui::VarBorrowMut {{
        use runtime::ui::VarBorrowMut as V;
         match i {{
            {visit_vars_mut}
            _ => V::Fail,
        }}
    }}
}}
"#
